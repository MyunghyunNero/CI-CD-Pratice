# CI-CD-Pratice
쿠버네티스/도커 책을 보며 독학 (젠킨스 + 도커)


## 1. 쿠버네티스란? - 컨테이너 오케트레이션을 위한 솔루션
- 컨테이너 오스레이션이란? - 다수의 컨테이너를 유기적으로 연결, 실행 , 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 해주는 것

---------
## 2. 도커란? - 컨테이너를 만들고 관리하는 도구
- 컨테이너란? - 하나의 운영체제 안에서 커널을 공유하며 개별적인 실행 환경(CPU,네트워크,메모리와 같은 시스템 자원을 독자적으로 사용하도록 할당된 환경)을 제공하는 격리된 공간

### 2.1. 컨테이너와 이미지
- 이미지란? - 특정 환경에 대한 정보가 변하지 않고 저장되는 정적인 형태의 파일이다. 
- 컨테이너란? - 이미지를 동적인 형태로 변경한 것

>### 2.1.1 이미지
>1. 이미지는 레지스트리 라는 저장소에 모여있다.(레지스트리는 (https://hub.docker.com)도커허브처럼 공개된 유명레지스트리 일수도 있고 내부에 구축된 레지스트리 일수도 있음)
<pre>
<code>
docker search nginx 
</pre>
</code>

>위 명령어 실행이 도커허브에서 저장된 이미지 목록을 가져온다.
<pre>
<code>
docker pull nginx 
</pre>
</code>
위 명령어 실행이 이미지를 내려받을 수 있다.

>### 2.1.2 이미지 태그
>- 태그는 이름이 동일한 이미지에 추가하는 식별자
>### 2.1.3 이미지의 레이어 구조
>- 이미지는 사실 압축파일에 가까움
>- 같은 내용일 경우 여러 이미지에 동일한 레이어를 공유함(용량 적게차지)
-----
실습.

<img width="735" alt="image" src="https://user-images.githubusercontent.com/91003734/227120274-ccc74268-c12f-4c77-91d9-8fb5716aa009.png">

위 사진을 분석하면
1. nginx 이미지를 내려 받는다.
2. tag가 stable하게 받는다 . 기본은 latest(최신) 이다.
3. 레이어 fcdb9667c46b,8dc7b6799e96 등 이 다 레이어를 뜻한다. 즉 nginx 버전이 달라져 코드가 추가되어도 저 레이어들은 이미 다운로드 되었기에 추가된것만 받는다 (git commit 느낌?) - 즉 태그가 다른, 버전이 다른 이미지를 다운로드 받아도 실제 저장된 용량은 훨씬 적다(공유하는 레이어가 있기 때문)
4. 다이제스트(digest):이미지의 고유식별자
----

### 2.2 컨테이너 실행하기
<pre>
<code>
docker run -d --restart always nginx
</pre>
</code>
이 코드를 이용해 실행 가능 

옵션 알아보기
- -d(--detach):컨테이너를 백그라운드에서 구동
- --restart always : 프로그램이 오류로 중단되어도 즉시 재시작하게  해줌(always 이외에 no(재시작하지 않음),on-failure(재시작함 :=always?),unless-stopped(사용자가 직접 정지하지 않은 컨테이너만 시작)  가 있음)

하지만 이러면 오류가 나온다. 로컬호스트에 nginx호출하기 위해 포트 80을  호출했으나 우리는 도커에 nginx,포트 80 이 위치하기 때문이다. 즉 우리는 로컬호스트에 들어온 요청을 도커랑 연결할 필요가 있다.
<pre>
<code>
docker run -d -p 8080:80 --restart always nginx
</pre>
</code>

- -p는 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션<요청받을 호스트 포트>:<연결할 컨테이너 포트>

---
### 2.3 컨테이너 내부 파일 변경
- docker cp: docker cp <호스트 경로> <컨테이너이름>:<컨테이너 내부경로> 형식으로 호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사
- Dockerfile ADD : 이미지 생성하는 Dockerfile에 ADD구문으로 컨테이너 내부로 복사할 파일 지정
- 바인드 마운트 : 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법 (데이터베이스나 서버의 첨부파일 같이 컨테이너 바뀌어도 사라지면 안되는 자료 이용)
- 볼륨 : 도커가 관리하는 볼륨을 컨테이너와 연결


### 2.4 볼륨으로 호스트와 컨테이너 연결
<pre>
<code>
docker volume create nginx-volume 
</pre>
</code>

nginx-volume 라는 볼륨을 호스트 파일에 생성함

<pre>
<code>
docker run -d -v [볼륨 이름]:[컨테이너 디렉터리]
</pre>
</code>

위의 코드로 볼륨파일과 컨테이너 파일이 동기화 된다.

### 2.5 컨테이너 이미지 만들기
기본에 제공되는 이미지 사용도 가능하나 만들 수도 있다.
만들기 위해 Dockfile 필요 

>#### 2.5.1컨테이너 빌드과정(자바 기준)
>자바 소스 빌드 -> 도커파일 작성 -> 도커파일 빌드-> 빌드완료
<pre>
<code>
docker build -t test .
</pre>
</code>

>위 코드는 컨테이너 이미지를 빌드 -t는 만들어질 이미지
뒤에 .은 이미지에 원하는 내용을 추가하거나 변경하는데 필요한 작업 공간을 현재 디렉터리로 지정

>#### 2.5.2 도커 파일 문법
1. FROM <이미지 이름>:[태그] - 이미지를 가져오고 이미지 내부에서 컨테이너 이미지를 빌드 .(즉 누군가가 만든 이미지에 내 코드를 추가하는 느낌) (ex)mport 
2. LABEL <레이블 이름>=<값>  - 이미지에 부가적인 설명을 위한 레이블
3. EXPOSE <숫자> - 생성된 이미지로 컨테이너를 구동할 떄 어떤 포트를 사용하는지 
4. COPY <호스트 경로> <컨테이너 경로> -컨테이너 경로에 호스트경로 파일 복사 (주로 실행파일 원하는 디렉터리로 옮김)
5. WORKDIR <작업 위치> - 작업위치를 변경함  (ex) cd /opt
6. ENTRYPOINT ["명령어","옵션",...,"옵션] -명렁어 실행 예를들어, ./java -jar app-in-image.jar
---
# docker 명령어 모음
<pre>
<code>
docker search {찾는 이미지} - 이미지를 찾음(도커 허브나 내부 레지스트리에서)
docker pull {이미지} - 이미지를 다운 받음
docker history {이미지} - 이미지 생성과정 볼 수 있음
docker ps - 생성한 컨테이너 확인
docker exec <컨테이너 id|이름> <명령어> - 컨테이너 내부에 명령어 
docker volume create {볼륨파일} -볼륨 파일 만들기
docker run -d -v [볼륨 이름]:[컨테이너 디렉터리] - 볼륨과 컨테이너 디렉터리 연결하기
docker stop <컨테이너 ID|이름>  -컨테이너 중지
docker rm <컨테이너>  -컨테이너 삭제
docker rmi <이미지>    -이미지 삭제
</pre>
</code>